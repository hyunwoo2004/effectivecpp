#include<iostream>

// Effective C++
// 2. 생성자, 소멸자 및 대입 연산자
// 항목 11: operator=에서는 자기대입에 대한 처리가 빠지지 않도록 하자

// 언뜻 보기에 명확하지 않은 이러한 자기대입이 생기는 이유는 여러 곳에서 하나의 객체를 참조하는 상태, 즉 중복참조(aliasing) 때문임
// 같은 타입으로 만들어진 객체 여러 개를 참조자 혹은포인터로 물어 놓고 동작하는 코드를 작성한 때는 같은 객체는 사용될 가능성을 
// 고려하는 것이 일반적으로 바람직한 자세임!

// 사실, 같은 클래스 계통에서 만들어진 객체라 해도 굳이 똑같은 타입으로 선언할 필요까지는 없음
// 파생 클래스 타입의 객체를 참조하거나 가리키는 용도로 기본 클래스의 참조자나 포인터를 사용하면 됨
// 예시
class Base {...};
class Derived {...};      
void something(const Base& rb,                // rb 및 *pd는 원래 같은
                Derived* pd);                 // 객체였을 수도 있음

//   뒤 항목들(13, 14)에 따른다면 우리는 자원 관리 용도로 항상 객체를 만들어야 할 것이고, 이렇게 만든 자원 관리 객체들이 복사될 때
// 나름대로 잘 동작하도혹 코딩할 게 분명함 -> 이때 조심해야 하는 것이 대입 연산자임
// 이 연산자는 우리가 신경쓰지 않아도 자기대입에 대해 안전하게 동작해야 함

int main() 
{

}


