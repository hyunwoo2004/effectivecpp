#include<iostream>

// Effective C++
// 2. 생성자, 소멸자 및 대입 연산자
// 항목 8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

// 소멸자로부터 예외가 터져 나가는 경우를 C++ 언어에서 막는 것은 아니지만, 실제 상황을 보면
// 확실히 우리가 막아야 한다는 것을 알게 될 것임
// 예시
class Widget {
public:
  ...
  ~Widget() {...}      // 이 함수로부터 예외가 발생된다고 가정함
};

void doSomeThing() { 
  std::vector<Widget> v;
  ...
}  // v는 여기서는 자동으로 소멸됨
// vector 타입의 객체 v, 다시 말해 벡터 v가 소멸될 때, 자신이 거느리고 있는 Widget들 전부 소멸시킬 책임은 바로 이 벡터에게 있음
// v에 들어 있는 Widget이 열 개인데, 첫 번째 것을 소멸시키는 도중에 예외를 발생되었다고 가정
// 나머지 아홉 개는 여전히 소멸되어야 하므로, v는 이들에 대해 소멸자를 호출해야 할 것임
// 그런데 이 과정에서 문제가 또 터졌다고 가정
// 두번째 Widget에 대해 호출된 소멸자에서 예외가 던져지면 어떻게 되는가?
// 현재 활성화된 예외가 두개가 되면서 C++의 입장에서는 감당하기 어려움
// 이 두 예외가 동시에 발생한 조건이 어떤 미묘한 조건이냐에 따라 프로그램 실행이 종료되는지 아니면 정의되지 않은 동작을 보이게 됨
// -> 이 경우 프로그램이 정의되지 않은 동작이 보임
// 어떤 표준 라이브러리 컨테이너를 사용하든 배열을 사용하든 마찬가지(근데 컨테이너나 배열을 써서 생긴 문제가 아님)
// 문제의 원인은 소멸자에서 예외가 터져 나오는 것을 내버려 둔 것임
// C++은 예외를 내보내는 소멸자를 좋아하지 않음!!




int main() {

}          
