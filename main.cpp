#include<iostream>

// Effective C++
// 2. 생성자, 소멸자 및 대입 연산자
// 항목 11: operator=에서는 자기대입에 대한 처리가 빠지지 않도록 하자

// 여기서 찾을 수 있는 자기 참조 문제는 operator= 내부에서 *this와 rhs가 같은 객체일 가능성이 있음
// 이 둘이 같은 객체이면, delete 연산자가 *this 객체의 비트맵에만 적용되는 것이 아니라 rhs의 객체까지 적용됨
//   이 함수가 끝나는 시점이 되면 해당 Widget 객체는 자신의 포인터 멤버를 통애 물고 있던 객체가 어처구니없게도
// 삭제된 상태가 되는 불상사를 당하게 됨

// 이런 에러에 대한 대책은 예전부터 있어 왔음. 전통적인 방법은 operator=의 첫머리에서 일치성 검사(identity test)를 통해
// 자기대입을 점검하는 것
Widget& operator=(const WIdget& rhs)
{
  if(*this == &rhs) return *this;      // 객체가 같은지, 즉 자기대입인지 검사함
                                       // 자기대입이면 아무것도 안함
  delete pb;
  pb = new Bitmap(rhs.pb);

  return *this;
}
// 이렇게 하면 되기는 하지만, 이전 버전이 operator=이 자기 대입에 안전하지 못할 뿐만 아니라 예외에도 안전하지 않다는 말을 한 적 있음
// 에외 안전성에 대해서는 이 코드도 여전히 문젯거리를 안고 있음
// 특히 신경쓰이는 부분이 'new Bitmap' 표현식임
// 이 부분에서 예외가 터지게 되면(동적 할당에 필요한 매모리가 부족하는 경우 등), 
// Widget 객체는 결국 삭제된 Bitmap을 가리키는 포인터를 껴안고 홀로 남게 욈
// 이런 포인터가 멋대로 떠다니게 두면 난리나는 건 당연할 일이 됨... (또 디버깅 모드로 찾을 때까지 시간이 낭비됨)


int main() 
{

}


