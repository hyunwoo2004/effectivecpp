#include<iostream>

// Effective C++
// 4. 설계 및 선언
// 항목 20: '값에 의한 전달'보다는 '상수객체 참조자'방식을 택하는 편이 대개 낫다

// 세상에나 Student 객체를 값으로 전달하는 데 날아간 비용을 계산해 보니 생성자 여섯 번에 소멸자 여섯 번임!

// 위의 것이 틀린 것도 아니며 또 바라지 않았던 동작도 아님
// 어쨌든 우리가 원하는대로 제대로 생성되고 소멸되고 있음
// 그렇지만, 가끔 위쪽도 바라보며 살면 좋지 않겠는가?
// 생성자 소멸자 호출을 몇 번씩 거치지 않고 넘어갈 수 있는 방법이 있다면 인생이 조금 더 반질반질 할 거임
// 그런데 그런 방법이 있음 - 상수 객체에 대한 참조자(referenc-to-const)로 전달하게 만드는 거임

bool validateStudent(const Student& s);

// 이렇게 하면 순식간에 훨씬 효율적인 코드로 바뀜
// 새로 만들어지는 객체 같은 것이 없기 때문에, 생성자와 소멸자가 전혀 호출되지 않음
// 여기서 새겨둬야 할 부분이 매개변수 선언문에 있는 const임 - 이것이 아주 중요!
// 원래의 validateStudent는 Student 객체에 어떤 변화가 생기더라고 그 변화로부터 안전하게 보호를 받는다는 점을 알고 있음
// 그도 그럴 것이 valideateStudent가 상대하는 Student 객체는 원본이 아닌 사본이기 때문임
// 그런데 이제는 Student 객체의 전달 방식이 참조에 의한 전달임
// 매개변수 앞에 const가 붙은 건 바로 그 때문인데, 이것이 붙지 않으면 validateStudent함수로 넘어간 Student 객체가 변할지도 모른다는 걱정을 호출부가 해야 함

// 참조에 의한 전달 방식으로 매개변수를 넘기면 복사손실 문제(slicing problem)가 없어지는 장점도 있음
// 파생 클래스 객체가 기본 클래스 객체로서 전달되는 경우는 드물지 않게 접할 수 있는데, 이때 이 객체가 값으로 전달되면 기본 클래스의 복사 생성자가 호출되고,
// 파생 클래스 객체로 동작하게 해 주는 특징들이 '싹둑 잘려' 떨어지고 만다.
// 우리 손에 남을 것은 파생 클래스의 징표가 거세된 기본 클래스 객체뿐임
// 뭐, 놀랄 사실은 아님 - 기본 클래스 생성자가 만들었으니...
// 모르긴 해도 우리가 원한 결과가 이것일리 없음


int main() 
{

} 




