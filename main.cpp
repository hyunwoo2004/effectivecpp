#include<iostream>

// Effective C++
// 3. 자원 관리
// 항목 14: 자원 관리 클래스의 복사 동작에 대래 진지하게 고찰하자

// 사실, 힙에 생기지 않는 자원은 auto_ptr 혹은 shared_ptr 등의 스마트 포인터로 처기해 주기엔 맞지 않다는 것이 일반적인 견해임
// 항상 그런 것은 아니지만, 자원 관리 클래스를 우리가 스스로 만들어야 할 필요를 느끼는 경우가 바로 이런 경우임

// 그런데 Lock 객체가 복사된다면 어떻게 해야 하는가?
{
  Lock m11(&m);                                  // m에 잠금을 검
  Lock m12(m11);                                 // m11을 m12로 복사함. 어떨게 되는가?
}
// 사실 이 질문은 약간 더 일반화해서 이렇게 정리할 수 있음 - RAII 클래스를 만들어 본 사람이라면 한 번쯤 고민해 볼만한 질문임
// "RAII 객체가 복사될 때 어떤 동작이 이루어져야 하는가?"임
// 아마도 열에 아홉은 다음의 선택지 중 하나를 골라야 함
// 1. 복사를 금지한다.
// 실제로, RAII 객체가 복사되도록 놔두는 것 자체가 말이 안 되는 경우가 꽤 많음
// 위의 Lock 같은 클래스도 이런 부류에 속함
// 어떤 스레드 동기화 객체에 대한 '사본'이라는 게 실제로 거의 의미가 없음
// 복사하면 안 되는 RAII 클래스에 대해서는 반드시 복사가 되지 않도록 막아야 함 - 복사를 막는 방법은 항목 6 참고
// -> 복사 연산(함수)을 private 멤버로 만드는 것임

int main() 
{

}



