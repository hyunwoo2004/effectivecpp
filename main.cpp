#include<iostream>

// Effective C++
// 3. 자원 관리
// 항목 14: 자원 관리 클래스의 복사 동작에 대래 진지하게 고찰하자

// 사실, 힙에 생기지 않는 자원은 auto_ptr 혹은 shared_ptr 등의 스마트 포인터로 처기해 주기엔 맞지 않다는 것이 일반적인 견해임
// 항상 그런 것은 아니지만, 자원 관리 클래스를 우리가 스스로 만들어야 할 필요를 느끼는 경우가 바로 이런 경우임

// 그런데 Lock 객체가 복사된다면 어떻게 해야 하는가?
{
  Lock m11(&m);                                  // m에 잠금을 검
  Lock m12(m11);                                 // m11을 m12로 복사함. 어떨게 되는가?
}
// 사실 이 질문은 약간 더 일반화해서 이렇게 정리할 수 있음 - RAII 클래스를 만들어 본 사람이라면 한 번쯤 고민해 볼만한 질문임
// "RAII 객체가 복사될 때 어떤 동작이 이루어져야 하는가?"임
// 아마도 열에 아홉은 다음의 선택지 중 하나를 골라야 함
// 3. 관리하고 있는 자원을 진짜로 복사함
// 때에 따라서는 자원을 원하는 대로 복사할 수도 있음
// 이때는 '자원을 다 썼을 때 각각의 사본을 확실히 해제하는 것'이 자원 관리 클래스가 필요한 유일한 명분이 됨
// 자원 관리 객체를 복사하면 그 객체가 둘러싸고 있는 자원까지 복사해야 함 - 즉, '깊은 복사(deep copy)'를 수행해야 한다는 말임

// 몇몇 구현환경에서 표준 string 타입을 구현해 놓은 모습을 보면, 문자열을 구성하는 원소들을 힙 메모리에 저장해 놓고 
// 이 메모리에 대한 포인터를 데이터 멤버로 갖고 있는 경우를 종종 보게 됨
// 이렇게 설계된 string 타입으로 생성한 객체는 결국 힙 메모리를 물고 있는 형태가 됨
// 이때 이 객체를 복사하면, 사본은 포인터 및 그 포인터를 가리키는 (새로운) 힙 메모리를 갖게 됨
// -> 깊은 복사의 한 예시

int main() 
{

}



