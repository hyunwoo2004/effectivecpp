#include<iostream>

// Effective C++
// 3. 자원 관리
// 항목 15: 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자

// RAII 클래스를 실제 자원으로 바꾸는 방법으로서 명시적 변환을 제공할 것인지(get 멤버함수 등)
// 아니면 암시적 변환을 허용할 것인지에 대한 결정은 그 RAII 클래스만의 특정한 용도와 사용 환경에 따라 달라짐
// 어쨌든 가장 잘 설계한 클래스라면 항목 18의 조언에 따라 "맞게 쓰기에는 쉽게, 틀리게 쓰기에는 어렵게" 만들어져야 함
// 늘 그런 것은 아니지만, 암시적 변환보다는 get 등의 명시적 변환 함수를 제공하는 쪽이 나을 때가 많음
// 원하지 않은 타입 변환이 일어날 여지를 줄여주는 것은 확실함
// 하지만 암시적 타입 변환에서 생기는 사용 시의 자연스러움이 빛을 발하는 경우도 있다는 점도 알아두자!

// 혹시 이런 생각한 사람이 있음? - RAII 클래스에서 자원 접근 함수를 열어 주는 설계가 혹시 설계화에 위배되는 것은 아닌가?
// 솔직히 그렇긴 하지만, 처음부터 틀려먹은 엉망진창 설계도 아님
// RAII 클래스는 애초부터 데이터 은닉이 목적이 아님!
// 원하는 동작(자원 해제)이 실수 없이 이루어지도록 하면 OK임
// 궅이 원한다면 '자원 해제'라는 기본 기능 위에 캡슐화 기능을 얹을 수는 있겠지만, 꼭 필요한 것은 아님
// 말이 나왔으니 하는 말임 - 시중에 나와 있는 RAII 클래스 중에는 이미 자원의 엄격한 캡슐화와 느슨한 캡슐화를 동시에 지원하는 것들도 꽤 있음
// tr1::shared_ptr이 대표적인 예인데, 이 클래스는 참조 카운팅 매커니즘에 필요한 장치들은 모두 캡슐화하고 있지만, 
// 그와 동시에 자신이 관리하는 포인터를 쉽게 접근할 수 있는 통로도 여전히 제공하고 있음
// 꼼꼼히 제대로 설계된 클래스가 그렇듯, 사용자가 볼 필요가 없는 데이터는 가리지만 고객 차원에서 꼭 접근해야 하는 데이터는 열어 주는 것임!

int main() 
{

}



