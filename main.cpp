#include<iostream>

// Effective C++
// 2. 생성자, 소멸자 및 대입 연산자
// 항목 8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

// 위에 두 방법은 어느 쪽을 선택하든 특별히 좋을 건 없음 (둘 다 문제점이 있음)
// 중요한 것은 close가 최초로 예외를 던지게 된 요인에 대해 프로그램이 어떤 조치를 취할 수 있는가인데
// 이런 부분에 대한 대책이 전무함

// 더 좋은 전략을 생각해보자
// DBConn 인터페이스를 잘 설계해서, 발생할 소지가 있는 문제에 대처할 기회를 사용자가 가질 수 있도록 하면 어떨까?
// 예시로, DBConn에서 close 함수를 직접 제공하게 하면 이 함수의 실행 중에 발생하는 예외를 사용자가 직접 처리가 가능함
// DBconnection이 닫혔는지의 여부를 유지했다가, 닫히지 않았으면 소멸자에서 닫을 수 있음(DB 연결이 누출되지 않음)
// 그러나 소멸자에서 호출하는 close마저 실패한다면 위에 했던 2가지 방법 중 선택해서 할 수 밖에 없음
class DBConn {
public:
  ...
  void close() {                                 // 사용차의 호출을 배려(?)해서
    db.close();                                  // 새로 만든 함수
    closed = true;
  }
  ~DBConn() {
    if(!closed)
      try {                                      // 사용자가 연결을 안 닫았으면
        db.close();                              // 여기서 닫아 봄
      } catch (...) {
        // close 호출이 실패했다는 로그를 작성    // 연결을 닫다가 실패하면
        ...                                      // 실패를 알린 후에 
      }                                          // 실행을 끝내거나 예외를 삼킴
  }
private:
  DBConnection db;
  bool closed;
};
// close 호출의 책임을 DBconn의 소멸자에서 DBConn의 사용자로 떠넘기는 이런 아이디어는 무책임한 책임 전가로 볼 순 있음
// 다른 항목에는 "제대로 쓰기에 쉬운 인터페이스를 만들라"는 조언을 어긴거일 수도 있다는 생각을 가질 수 있음
// 그러나 둘다 아님


int main() 
{
  
}

