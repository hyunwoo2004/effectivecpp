#include<iostream>

// Effective C++
// 2. 생성자, 소멸자 및 대입 연산자
// 항목 8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

// 예외를 던지고 실패할 수 있는 코드를 소멸자에 넣어야만 하는 경우?
// 예시: 데이터베이스 연결을 나타내는 클래스
class DBConnection {
public:
  ...
  static BDConnection create();
                             

  void close();        
};  

class DBConn {              
public:                       
  ...
  ~DBConn();
private:
  DBConnection db;
};
// close 호출만 일사천리로 성공하면 아무런 문제가 없는 코드
// 그러나 close를 호출했는데 예외가 발생한다면?
// -> DBConn의 소멸자는 분명히 이 예외를 전파할 것
//    쉽게 말해, 그 소멸자에서 예외가 나가도록 내버려 두게 됨 (문제 발생!!!)
// 예외를 던지는 소멸자 --> 우리의 '걱정거리'

// 이 문제를 피하는 방법
// 2. close를 호출한 곳에서 일어난 예외를 삼켜 버리자
DBConn::~DBConn() 
{
  try { db.close(); }
  catch (...) {
    // close 호출이 실패했다는 로그를 작성
  }
}
// 대부분의 경우에서 예외를 삼키기는 좋은 발상이 아님 (중요한 정보<무엇이 잘못됐는지를 알려주는 정보>가 묻혀 버리기 떄문)
// 그러나 때에 따라서는 불완전한 프로그램 종료 혹은 미정의 동작으로 인해 입은 위험을 감수하는 것보다 그냥 예외를 먹어버리는 게 나을 수도 있음
// 단, '예외 삼키기'를 선택한 것이 제대로 빛을 보려면, 발생한 예외를 그냥 무시한 뒤라도 프로그램이 신뢰성 있게 실행을 지속할 수 있어야 함


int main() 
{
  
}

