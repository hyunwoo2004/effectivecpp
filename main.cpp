#include<iostream>

// Effective C++
// 4. 설계 및 선언
// 항목 18: 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자

// 이야기가 좀 길어지긴 했지만 이번 항목의 주제는 tr1::shared_ptr이 아님(위 항목 이름이 주제임)
// 그러나 tr1::shared_ptr을 사용하면 사용자가 무심코 저지를 수 있는 실수 몇 가지를 없앰으로써 '그러한' 인터페이스를 만드는 데 쉽게 다가갈 수 있음
// 이 정도면 전반적인 사용법을 알아본 값어치는 한다고 생각함
// 참고로, tr1::shared_ptr을 구현한 제품 중 가장 흔히 쓰이는 것은 부스트 라이브러리(항목 55 참고)임.
// 부스트의 shared_ptr은 일단 크기가 원시 포인터의 두 배임
// 그리고 내부 관리 데이터 및 삭제자 메커니즘을 돌릴 데이터를 위해 동적 할당 메모리를 사용하며, 다중스레드로 돌아가는 프로그램을 지원할 경우에는 참조 카운트를 변경할 떄 스레드 동기화 오버헤드를 일으킴
// (다중스레드 지원을 비활성화시킬 수도 있음. 선행 처리자 기호를 정의하면 됨)
// 간단히 말해 이 클래스를 사용하면 원시 포인터보다 크고 느리며 게다가 내부 관리용 동적 메모리까지 추가로 매달림
// 하지만 이런 것들 때문에 응용 프로그램에서 런타임 비용이 눈에 띄게 늘어나는 경우는 어지간해서는 찾기 힘들 거임
// 반면에 사용자 실수가 눈에 띄게 줄어드는 경우는 모든 사람들이 잡아낼 수 있을 정도임

int main() 
{
}


