#include<iostream>

// Effective C++
// 3. 자원 관리
// 항목 14: 자원 관리 클래스의 복사 동작에 대래 진지하게 고찰하자

// 사실, 힙에 생기지 않는 자원은 auto_ptr 혹은 shared_ptr 등의 스마트 포인터로 처기해 주기엔 맞지 않다는 것이 일반적인 견해임
// 항상 그런 것은 아니지만, 자원 관리 클래스를 우리가 스스로 만들어야 할 필요를 느끼는 경우가 바로 이런 경우임

// 그런데 Lock 객체가 복사된다면 어떻게 해야 하는가?
{
  Lock m11(&m);                                  // m에 잠금을 검
  Lock m12(m11);                                 // m11을 m12로 복사함. 어떨게 되는가?
}
// 사실 이 질문은 약간 더 일반화해서 이렇게 정리할 수 있음 - RAII 클래스를 만들어 본 사람이라면 한 번쯤 고민해 볼만한 질문임
// "RAII 객체가 복사될 때 어떤 동작이 이루어져야 하는가?"임
// 아마도 열에 아홉은 다음의 선택지 중 하나를 골라야 함
// 2. 관리하고 있는 자원에 대해 참조 카운팅을 수행한다
// 자원을 사용하고 있는 마지막 객체가 소멸될 때가지 그 자원을 저 세상으로 안 보내는 게 바람직한 경우도 종종 있음
// 이런 경우에는, 해당 자원을 참조하는 객체의 개수에 대한 카운트를 증가하는 식으로 RAII 객체의 복사 동작을 만들어야 함
// 참고로, 이런 방식은 현재 tr1::shared_ptr이 사용하고 있음


int main() 
{

}



