#include<iostream>

// Effective C++
// 2. 생성자, 소멸자 및 대입 연산자
// 항목 8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

// 위에 두 방법은 어느 쪽을 선택하든 특별히 좋을 건 없음 (둘 다 문제점이 있음)
// 중요한 것은 close가 최초로 예외를 던지게 된 요인에 대해 프로그램이 어떤 조치를 취할 수 있는가인데
// 이런 부분에 대한 대책이 전무함

// 더 좋은 전략을 생각해보자
// DBConn 인터페이스를 잘 설계해서, 발생할 소지가 있는 문제에 대처할 기회를 사용자가 가질 수 있도록 하면 어떨까?
// 예시로, DBConn에서 close 함수를 직접 제공하게 하면 이 함수의 실행 중에 발생하는 예외를 사용자가 직접 처리가 가능함
// DBconnection이 닫혔는지의 여부를 유지했다가, 닫히지 않았으면 소멸자에서 닫을 수 있음(DB 연결이 누출되지 않음)
// 그러나 소멸자에서 호출하는 close마저 실패한다면 위에 했던 2가지 방법 중 선택해서 할 수 밖에 없음
class DBConn {
public:
  ...
  void close() {                                 // 사용차의 호출을 배려(?)해서
    db.close();                                  // 새로 만든 함수
    closed = true;
  }
  ~DBConn() {
    if(!closed)
      try {                                      // 사용자가 연결을 안 닫았으면
        db.close();                              // 여기서 닫아 봄
      } catch (...) {
        // close 호출이 실패했다는 로그를 작성    // 연결을 닫다가 실패하면
        ...                                      // 실패를 알린 후에 
      }                                          // 실행을 끝내거나 예외를 삼킴
  }
private:
  DBConnection db;
  bool closed;
};
// close 호출의 책임을 DBconn의 소멸자에서 DBConn의 사용자로 떠넘기는 이런 아이디어는 무책임한 책임 전가로 볼 순 있음
// 다른 항목에는 "제대로 쓰기에 쉬운 인터페이스를 만들라"는 조언을 어긴거일 수도 있다는 생각을 가질 수 있음
// 그러나 둘다 아님

//  어떤 동작이 예외를 일으키면서 실패할 가능성이 있고 또 그 예외를 처리해야 할 필요가 있다면, 
// 그 예외는 '소멸자가 아닌 다른 함수에서 비롯된 것이어야 한다'는 것이 포인트!
//  예외를 일으키는 소멸자는 시한폭탄이나 마찬가지라서 프로그램 불완전 종료 혹은 미정의 동작의 위험이 내포함
// 예제를 보면 사용자가 호출할 수 있는 close 함수를 두긴 했지만 부담을 떠넘기는 모양새는 아님
// -> 사용자에게 에러를 처리할 수 있는 기회를 주는 것임 (이것마저 없다면 사용자는 예외에 대처할 기회를 못 잡을 것임)
// 물론, 굴러 들어온 기회를 사용자 쪽에서 갖다 버리는 경우도 있음 (이거는 무시하자!, 그래도 DBConn의 소멸자에서 어떻게든 마무리해 줄 수 있음)

int main() 
{
  
}

