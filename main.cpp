#include<iostream>

// Effective C++
// 2. 생성자, 소멸자 및 대입 연산자
// 항목 8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

// 예외를 던지고 실패할 수 있는 코드를 소멸자에 넣어야만 하는 경우?
// 예시: 데이터베이스 연결을 나타내는 클래스
class DBConnection {
public:
  ...
  static BDConnection create();
                             

  void close();        
};  

class DBConn {              
public:                       
  ...
  ~DBConn();
private:
  DBConnection db;
};
// close 호출만 일사천리로 성공하면 아무런 문제가 없는 코드
// 그러나 close를 호출했는데 예외가 발생한다면?
// -> DBConn의 소멸자는 분명히 이 예외를 전파할 것
//    쉽게 말해, 그 소멸자에서 예외가 나가도록 내버려 두게 됨 (문제 발생!!!)
// 예외를 던지는 소멸자 --> 우리의 '걱정거리'

// 이 문제를 피하는 방법
// 1. close에서 예외가 발생하면 프로그램을 바로 끝냄 - 대부분 abort()를 호출함
DBConn::~DBConn() 
{
  try { db.close(); }
  catch (...) {
    // close 호출이 실패했다는 로그를 작성
    std::abort();
  }
}
// 객체 소멸이 진행되다가 에러가 발생한 후에 프로그램 실행을 계속할 수 없는 상황이라면 꽤 괜찮은 선택임
//   소멸자에서 생긴 예외를 그대로 흘려 내보내다가 정의되지 않은 동작에까지 이를 수 있다면
// 이런 불상사를 막는다는 의미에서 어느 정도 장점도 있음
// 간단히 말하면, abort를 호출해서 못 볼꼴을 미리 안 보여 주겠다는 의도

int main() 
{
  
}

